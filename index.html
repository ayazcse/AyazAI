<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI:az: Fullscreen Fixed Input Chat (Light/Dark Mode)</title>
    <!-- ADDED: Browser Icon (Favicon) - Using a simple, modern sparkling SVG icon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>âœ¨</text></svg>">
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Tone.js for typing sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* --- Base Styling and Theme Variables (CSS Variables for dynamic theming) --- */
        body {
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        
        /* Define Light Mode Variables */
        :root {
            --bg-primary: #f3f4f6; /* Gray-100 (Outer Background) */
            --bg-secondary: #ffffff; /* White (Header/Input Bar) */
            --text-color: #1f2937; /* Dark Gray (Text) */
            --border-color: #e5e7eb; /* Gray-200 (Borders/Dividers) */
            
            /* Light Mode Bubble Colors (from previous request) */
            --user-bubble-bg: #fff3b0; /* Soft Yellow */
            --user-bubble-border: #ffeb8e;
            --model-bubble-bg: #cceeff; /* Light Sky Blue */
            --model-bubble-border: #99ccff;
        }

        /* Define Dark Mode Variables */
        body.dark {
            --bg-primary: #000000; /* Pure Black (Outer Background) */
            --bg-secondary: #000000; /* Pure Black (Header/Input Bar) */
            --text-color: #f3f4f6; /* Light Gray (Text) */
            --border-color: #1f2937; /* Dark Gray (Borders/Dividers) */
            
            /* Dark Mode Bubble Colors (from user image) */
            --user-bubble-bg: #374151; /* Dark Gray (AI/Model) */
            --user-bubble-border: #4b5563;
            --model-bubble-bg: #1e40ff; /* Bright Blue (User) */
            --model-bubble-border: #3b82f6;
        }
        
        /* Apply theme variables to specific elements */
        body { background-color: var(--bg-primary); }
        .themed-header, .input-container { background-color: var(--bg-secondary); border-color: var(--border-color); }
        .themed-input { 
            background-color: var(--bg-secondary); 
            border-color: var(--border-color); 
            color: var(--text-color);
        }
        .themed-status { background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-color); }
        .themed-file-preview { background-color: var(--border-color); }

        /* Main chat history container is now handled by flex-grow and overflow-y-auto on its parent */

        /* --- Custom Bubble Styling --- */
        .user-bubble, .model-bubble {
            padding: 0.8rem 1.1rem; 
            border-radius: 1.2rem; 
            word-wrap: break-word; 
            overflow-wrap: break-word;
            max-width: 85%; 
            line-height: 1.4;
            transition: background-color 0.3s, color 0.3s;
        }
        
        /* MODEL Bubble (AI) - Left Aligned */
        .model-bubble {
            background-color: var(--model-bubble-bg); 
            border-radius: 1.2rem 1.2rem 1.2rem 0.5rem; 
            margin-right: auto;
            color: var(--text-color);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--model-bubble-border);
        }

        /* USER Bubble (Human) - Right Aligned */
        .user-bubble {
            background-color: var(--user-bubble-bg); 
            border-radius: 1.2rem 1.2rem 0.5rem 1.2rem; 
            margin-left: auto;
            color: var(--text-color);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--user-bubble-border);
        }

        /* Adjusting text color for dark mode where bubbles might be dark */
        body.dark .model-bubble {
            color: #f3f4f6; /* Light text for bright blue bubble */
        }
        body.dark .user-bubble {
            color: #f3f4f6; /* Light text for dark gray bubble */
        }

        /* Loader and Cursor */
        .loader {
            border-top-color: #6366f1; 
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .typing-cursor {
            display: inline-block;
            width: 1px;
            height: 1.2em;
            background-color: currentColor;
            animation: blink 0.7s infinite;
            margin-left: 2px;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* Removed fixed-input-bar CSS - handled by flex layout now */
    </style>
</head>
<!-- UPDATED: Set body to full height and use flex column layout, preventing body scrolling -->
<body class="p-0 flex flex-col h-screen overflow-hidden">

    <!-- 1. Header (FIXED AT TOP - flex-shrink-0) -->
    <header class="themed-header flex-shrink-0 w-full max-w-4xl mx-auto p-4 md:p-6 border-b flex justify-between items-center flex-wrap gap-4 z-10 shadow-md">
        
        <!-- Action Group: Theme Toggle, TTS & New Chat -->
        <div class="flex space-x-4 md:space-x-6">
            
            <!-- Theme Toggle -->
            <div class="flex flex-col items-center">
                <button id="theme-toggle" class="p-3 rounded-full transition-colors shadow-md" onclick="toggleTheme()">
                    <!-- Icon will be updated by JS -->
                </button>
                <span class="text-xs mt-1 font-medium text-gray-500 dark:text-gray-400">Theme</span>
            </div>

            <!-- TTS Toggle -->
            <div class="flex flex-col items-center">
                <button id="tts-toggle" class="p-3 rounded-full transition-colors shadow-md" onclick="toggleTts()">
                    <svg id="tts-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"></svg>
                </button>
                <span class="text-xs mt-1 font-medium text-gray-500 dark:text-gray-400">Audio</span>
            </div>

            <!-- New Chat Button (Clear History) -->
            <div class="flex flex-col items-center">
                <button id="new-chat-btn" 
                        class="p-3 rounded-full bg-red-500 text-white transition-colors shadow-md hover:bg-red-600" 
                        onclick="clearHistory()">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.74 9l-.387 7.054a2 2 0 01-1.995 2.5l-2.673-.535a2 2 0 01-1.995-2.5L9.26 9m1.06 4.676l-1.06-1.06M12 6h6m-6 0V4m-6 0h6"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5v-1a1 1 0 011-1h4a1 1 0 011 1v1M5 7h14a1 1 0 011 1v12a2 2 0 01-2 2H6a2 2 0 01-2-2V8a1 1 0 011-1z"></path></svg>
                </button>
                <span class="text-xs mt-1 font-medium text-gray-500 dark:text-gray-400">Clear</span>
            </div>
        </div>
        
        <!-- Gradient Title -->
        <h1 class="text-3xl sm:text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-cyan-500 to-indigo-600 tracking-wider flex-grow text-center min-w-[200px]">AI:az</h1>
        
        <!-- System Status -->
        <span id="system-status" class="themed-status text-xs sm:text-sm p-2 border rounded-lg shadow-inner">Status: Ready</span>
    </header>

    <!-- 2. Chat History Wrapper (SCROLLABLE AREA - flex-grow overflow-y-auto) -->
    <main id="chat-history-wrapper" class="flex-grow overflow-y-auto w-full max-w-4xl mx-auto p-4 md:p-6">
        <!-- Initial Welcome Message (Moved inside the scrollable area) -->
        <div id="initial-message-box" class="model-bubble p-3">
            <span id="initial-message">Hello! I am **AI:az**, a local assistant ready to chat. I support multi-file upload, text-to-speech, and location awareness. Please tap the volume icon to enable/disable voice replies!</span>
        </div>
        <!-- All chat bubbles will be appended to this container -->
        <div id="chat-history" class="flex flex-col space-y-3">
            <!-- Messages are injected here -->
        </div>
    </main>

    <!-- 3. Fixed Input Section (FIXED AT BOTTOM - flex-shrink-0) -->
    <div id="input-container" class="themed-header flex-shrink-0 w-full p-4 md:p-6 border-t shadow-2xl z-10">
        <div class="container mx-auto w-full max-w-4xl">
            
            <!-- File Preview Area -->
            <div id="file-preview-area" class="themed-file-preview mb-3 p-3 rounded-xl hidden transition-colors shadow-inner">
                <p class="text-sm font-semibold text-gray-700 mb-2">Attached Files (Max 5 will be processed):</p>
                <div id="file-list" class="space-y-1 text-sm text-gray-600">
                    <!-- Files will be listed here -->
                </div>
                <button onclick="clearFiles()" class="text-sm text-red-500 hover:text-red-600 mt-2">Remove All Files</button>
            </div>

            <!-- Chat Input Section (Responsive Flex Layout) -->
            <div class="flex space-x-2 sm:space-x-3">
                
                <!-- Location Button -->
                <button id="location-btn" 
                        class="flex-shrink-0 p-3 sm:p-4 bg-gray-500 text-white font-semibold rounded-xl focus:outline-none focus:ring-4 focus:ring-gray-300 transition-all shadow-md flex items-center justify-center hover:bg-gray-600 w-12 sm:w-14"
                        onclick="getLocation()">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                </button>
                
                <!-- File Upload Button (Paperclip Icon) -->
                <button id="file-upload-btn" 
                        class="flex-shrink-0 p-3 sm:p-4 bg-indigo-600 text-white font-semibold rounded-xl focus:outline-none focus:ring-4 focus:ring-indigo-500 transition-all shadow-md flex items-center justify-center hover:bg-indigo-700 w-12 sm:w-14"
                        onclick="document.getElementById('file-input').click()">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.57 6.57a4.5 4.5 0 01-6.364-6.364l6.57-6.57a6 6 0 018.485 8.485l-6.57 6.57a3 3 0 01-4.243-4.243l6.57-6.57"></path></svg>
                </button>
                
                <!-- Hidden File Input (Accepts multiple, any type) -->
                <input type="file" id="file-input" accept="*/*" multiple class="hidden" onchange="previewFiles(event)">

                <!-- Text Input -->
                <input type="text" id="user-input" placeholder="Message AI:az..."
                       class="themed-input flex-grow p-3 sm:p-4 border rounded-xl focus:ring-indigo-500 focus:border-indigo-500 placeholder-gray-500 text-sm sm:text-base shadow-inner"
                       onkeypress="if(event.key === 'Enter') sendMessage()">
                
                <!-- Send Button -->
                <button id="send-btn" 
                        class="flex-shrink-0 px-4 sm:px-6 py-3 sm:py-4 bg-indigo-600 text-white font-semibold rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-70 transition-all shadow-lg flex items-center justify-center w-12 sm:w-16"
                        onclick="sendMessage()">
                    <svg class="w-6 h-6 transform rotate-90" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 00.149 1.485.584.584 0 00.413.155H18.232a.584.584 0 00.413-.155 1 1 0 00.149-1.485l-7-14z"></path></svg>
                </button>
            </div>
        </div>
    </div>
            
    <!-- Custom Modal for Errors -->
    <div id="error-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-[100] flex items-center justify-center p-4">
        <div class="bg-white rounded-xl p-6 w-full max-w-sm transform transition-all shadow-2xl">
            <h3 class="text-xl font-bold text-red-600 mb-3">Error: System Alert</h3>
            <p id="error-message" class="text-gray-700 mb-4">An unknown error occurred.</p>
            <button class="w-full py-3 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700" onclick="document.getElementById('error-modal').classList.add('hidden')">Acknowledge</button>
        </div>
    </div>


    <script type="module">
        // --- API Key Injection ---
        const apiKey = "AIzaSyADkNwZsgNri_UtxgzqVWIaQCJqxSWzF0w"; 

        // --- Global State ---
        let userLocation = null; 
        let uploadedFiles = []; 
        let chatHistory = []; 
        
        // --- DOM Elements ---
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const locationBtn = document.getElementById('location-btn'); 
        // UPDATED: chatHistoryDiv is where messages are appended
        const chatHistoryDiv = document.getElementById('chat-history'); 
        // NEW: chatScrollWrapper is the parent that scrolls
        const chatScrollWrapper = document.getElementById('chat-history-wrapper'); 
        const errorModal = document.getElementById('error-modal');
        const errorMessage = document.getElementById('error-message');
        const systemStatusSpan = document.getElementById('system-status');
        const initialMessageBox = document.getElementById('initial-message-box');
        const fileInput = document.getElementById('file-input');
        const filePreviewArea = document.getElementById('file-preview-area');
        const fileListDiv = document.getElementById('file-list');
        const ttsIcon = document.getElementById('tts-icon');
        const themeToggleBtn = document.getElementById('theme-toggle');
        
        // --- Theme State ---
        // Initialize theme based on localStorage, default to 'light'
        let currentTheme = localStorage.getItem('theme') || 'light';

        // --- TTS State ---
        let isTtsEnabled = localStorage.getItem('ttsEnabled') === 'true';
        const TTS_MIN_LENGTH = 1; 

        // --- API Constants ---
        const MODEL_NAME = 'gemini-2.5-flash-preview-09-2025';
        const TTS_MODEL_NAME = 'gemini-2.5-flash-preview-tts'; 
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;
        const TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL_NAME}:generateContent?key=${apiKey}`; 
        
        // --- SYSTEM PROMPT: Professional, Clear, and Concise Format ---
        const SYSTEM_PROMPT = "You are a professional, highly articulate, and concise conversational assistant named AI:az, focused on providing structured, clear, and easy-to-understand responses with an Indian context and perspective. Maintain context and memory throughout the conversation. For any query requiring current or real-time information, you must use your search tool. You MUST respond in clear, plain text and AVOID using any Markdown formatting characters (like *, #, or `). Analyze and summarize any provided documents or images. Since this application runs locally without a database, your memory only lasts for this session.";
        
        const TYPING_DELAY = 20; // Default Milliseconds per character for non-TTS
        const TTS_TYPING_SPEED = 10; // Faster speed for sync with audio

        // --- Audio Setup (Tone.js) ---
        let synth = null;
        let audioContextInitialized = false;

        function initAudio() {
            if (!audioContextInitialized) {
                synth = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.005,
                        decay: 0.05,
                        sustain: 0,
                        release: 0.05
                    },
                    volume: -18
                }).toDestination();
                
                Tone.start().then(() => {
                    audioContextInitialized = true;
                    console.log("Audio Context Started for typing sound.");
                }).catch(e => console.error("Tone.js failed to start:", e));
            }
        }

        function playTypingSound() {
            if (audioContextInitialized && Tone.context.state === 'running' && !isTtsEnabled) {
                synth.triggerAttackRelease("G4", "64n"); 
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const initOnce = () => initAudio();
            sendBtn.addEventListener('click', initOnce, { once: true });
            userInput.addEventListener('focus', initOnce, { once: true });
        });
        
        // --- Theme Management ---
        
        /**
         * Applies the theme classes and updates the toggle button icon.
         */
        function applyTheme(theme) {
            currentTheme = theme;
            localStorage.setItem('theme', theme);
            
            if (theme === 'dark') {
                document.body.classList.add('dark');
                // Moon Icon
                themeToggleBtn.innerHTML = '<svg class="w-6 h-6 text-yellow-300" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>';
                themeToggleBtn.classList.remove('bg-gray-200');
                themeToggleBtn.classList.add('bg-gray-800');
                // Adjust file preview colors for dark mode manually as they have hardcoded text colors
                filePreviewArea.classList.add('bg-gray-900');
                filePreviewArea.querySelectorAll('p, .text-gray-600').forEach(el => el.classList.add('text-gray-300'));
            } else {
                document.body.classList.remove('dark');
                // Sun Icon
                themeToggleBtn.innerHTML = '<svg class="w-6 h-6 text-yellow-500" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 2a1 1 0 01.707.293l.353.353a1 1 0 01-1.414 1.414l-.353-.353A1 1 0 0114 4zm-4 14a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zm6-4a1 1 0 01.293.707l.353.353a1 1 0 01-1.414 1.414l-.353-.353A1 1 0 0116 14zm-14-2a1 1 0 011-1h1a1 1 0 110 2H3a1 1 0 01-1-1zm17-1a1 1 0 011 1h1a1 1 0 110 2h-1a1 1 0 01-1-1zM5 4.707A1 1 0 015.707 4l.353.353a1 1 0 01-1.414 1.414L4.293 5.414A1 1 0 015 4.707zM18 16a1 1 0 01-.707.293l-.353-.353a1 1 0 011.414-1.414l.353.353A1 1 0 0118 16zM6 16a1 1 0 01-.293.707l-.353.353a1 1 0 01-1.414-1.414l.353-.353A1 1 0 016 16zM12 7a5 5 0 100 10 5 5 0 000-10zM7 12a5 5 0 1110 0 5 5 0 01-10 0z" clip-rule="evenodd"></path></svg>';
                themeToggleBtn.classList.add('bg-gray-200');
                themeToggleBtn.classList.remove('bg-gray-800');
                // Restore file preview colors for light mode
                filePreviewArea.classList.remove('bg-gray-900');
                filePreviewArea.querySelectorAll('p, .text-gray-300').forEach(el => el.classList.remove('text-gray-300'));
            }
            updateTtsIcon(); // Ensure TTS icon style adapts
        }

        window.toggleTheme = function() {
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
        }
        
        // --- TTS Helper Functions (PCM to WAV) ---
        
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataLength = pcm16.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataLength);
            const dataView = new DataView(buffer);
            
            function writeString(view, offset, str) {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
            }

            let offset = 0;

            // RIFF chunk
            writeString(dataView, offset, 'RIFF'); offset += 4;
            dataView.setUint32(offset, 36 + dataLength, true); offset += 4;
            writeString(dataView, offset, 'WAVE'); offset += 4;

            // fmt chunk
            writeString(dataView, offset, 'fmt '); offset += 4;
            dataView.setUint32(offset, 16, true); offset += 4;      // ChunkSize (16 for PCM)
            dataView.setUint16(offset, 1, true); offset += 2;       // AudioFormat (1 for PCM)
            dataView.setUint16(offset, numChannels, true); offset += 2;
            dataView.setUint32(offset, sampleRate, true); offset += 4;
            dataView.setUint32(offset, byteRate, true); offset += 4;
            dataView.setUint16(offset, blockAlign, true); offset += 2;
            dataView.setUint16(offset, bytesPerSample * 8, true); offset += 2; // Bits per sample (16)

            // data chunk
            writeString(dataView, offset, 'data'); offset += 4;
            dataView.setUint32(offset, dataLength, true); offset += 4;
            
            // Write PCM data
            for (let i = 0; i < pcm16.length; i++, offset += 2) {
                dataView.setInt16(offset, pcm16[i], true); // Signed 16-bit little-endian
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }


        // --- TTS Toggle Management ---
        
        /**
         * Updates the TTS icon to reflect the current state and theme.
         */
        function updateTtsIcon() {
            const isDark = document.body.classList.contains('dark');

            if (isTtsEnabled) {
                // Volume On icon
                ttsIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1V7a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0111 1v12a1 1 0 01-.293.707l-4.707 4.707z"></path>';
                
                ttsIcon.parentNode.classList.remove('text-gray-400', 'bg-gray-200', 'bg-gray-800', 'text-gray-500');

                if (isDark) {
                     ttsIcon.parentNode.classList.add('text-orange-400', 'bg-gray-800');
                } else {
                     ttsIcon.parentNode.classList.add('text-orange-500', 'bg-yellow-100');
                }

            } else {
                // Volume Off/Mute icon
                ttsIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636M15 13.06L18 16m-4-6l3-3m-6 3H4a1 1 0 01-1-1V7a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0111 1v7.06"></path>';
                
                ttsIcon.parentNode.classList.remove('text-orange-500', 'bg-yellow-100', 'text-orange-400');
                
                if (isDark) {
                    ttsIcon.parentNode.classList.add('text-gray-500', 'bg-gray-800');
                } else {
                    ttsIcon.parentNode.classList.add('text-gray-400', 'bg-gray-200');
                }
            }
        }
        
        window.toggleTts = function() {
            isTtsEnabled = !isTtsEnabled;
            localStorage.setItem('ttsEnabled', isTtsEnabled);
            updateTtsIcon();
            if (isTtsEnabled) {
                console.log("Text-to-Speech Enabled.");
                initAudio();
            } else {
                console.log("Text-to-Speech Disabled. Typing sound effects enabled.");
            }
        }
        
        // --- Utility Functions ---

        function displayError(message) {
            errorMessage.textContent = message;
            errorModal.classList.remove('hidden');
            systemStatusSpan.textContent = "Status: Error";
        }

        async function fetchWithRetry(url, options, maxRetries = 3, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status === 429 && i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                        continue;
                    }
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; 
                }
            }
        }
        
        function displayMessage(text, role, files = null) {
            // Check if there is actual content in the main chat area (excluding the initial box)
            if (chatHistoryDiv.children.length > 0 || role === 'user' || text.trim() !== '') {
                initialMessageBox.classList.add('hidden');
            }

            const messageWrapper = document.createElement('div');
            messageWrapper.className = `flex flex-col ${role === 'user' ? 'items-end' : 'items-start'} w-full`;

            const bubble = document.createElement('div');
            const bubbleRoleClass = role === 'user' ? 'user-bubble' : 'model-bubble';
            bubble.className = `${bubbleRoleClass} mt-3`; 

            // Display attached files (if any)
            if (files && files.length > 0) {
                const fileContainer = document.createElement('div');
                fileContainer.className = 'flex flex-wrap gap-2 mb-2 p-1 border-b border-gray-300';
                
                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    const icon = `<svg class="w-4 h-4 mr-1 ${document.body.classList.contains('dark') ? 'text-gray-400' : 'text-indigo-500'}" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.57 6.57a4.5 4.5 0 01-6.364-6.364l6.57-6.57a6 6 0 018.485 8.485l-6.57 6.57a3 3 0 01-4.243-4.243l6.57-6.57"></path></svg>`;

                    if (file.mimeType.startsWith('image/')) {
                         // Display image preview
                        const img = document.createElement('img');
                        img.src = `data:${file.mimeType};base64,${file.data}`;
                        img.className = 'max-h-24 max-w-full rounded-md object-contain mb-1 shadow-md';
                        fileContainer.appendChild(img);
                    } else {
                        // Display generic file name
                        const bgColor = document.body.classList.contains('dark') ? 'bg-gray-800' : 'bg-gray-200';
                        fileItem.className = `text-xs flex items-center ${bgColor} p-1 rounded-md`;
                        fileItem.innerHTML = icon + `<span class="truncate">${file.name || file.mimeType}</span>`;
                        fileContainer.appendChild(fileItem);
                    }
                });
                bubble.appendChild(fileContainer);
            }

            const textSpan = document.createElement('span');
            textSpan.textContent = text;
            bubble.appendChild(textSpan);
            
            messageWrapper.appendChild(bubble);
            chatHistoryDiv.appendChild(messageWrapper);
            // UPDATED: Scroll the wrapper element
            chatScrollWrapper.scrollTop = chatScrollWrapper.scrollHeight; 
            
            return textSpan;
        }

        async function generateAndPlayTts(text) {
            if (text.length < TTS_MIN_LENGTH) {
                return null;
            }

            systemStatusSpan.textContent = "Status: Generating speech...";

            try {
                const ttsPayload = {
                    contents: [{ parts: [{ text }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: { prebuiltVoiceConfig: { voiceName: "Puck" } } 
                        }
                    },
                };
                
                const ttsOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(ttsPayload)
                };

                const ttsResponse = await fetchWithRetry(TTS_API_URL, ttsOptions);
                const ttsResult = await ttsResponse.json();
                
                const part = ttsResult?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    const rateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                    
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    const audioPlayer = new Audio(audioUrl);
                    audioPlayer.play().catch(e => {
                        console.error("Error playing audio (Browser blocked autoplay?):", e);
                        systemStatusSpan.textContent = "Status: Audio Playback Blocked";
                    });
                    
                    systemStatusSpan.textContent = "Status: Speaking reply...";
                    return audioPlayer;

                } else {
                    console.warn("TTS generation failed or returned invalid format. Proceeding without speech.");
                    systemStatusSpan.textContent = "Status: TTS API Failed";
                    return null;
                }

            } catch (e) {
                console.error("TTS API call failed:", e);
                let errorMessage = `TTS API call failed: ${e.message}`;
                if (e.message.includes("Quota exceeded")) {
                     errorMessage = "TTS Failed: API Quota Exceeded. Please try later or disable TTS.";
                }
                console.error(errorMessage);
                systemStatusSpan.textContent = errorMessage; 
                return null;
            }
        }


        async function typewriterEffect(targetElement, text, delay) {
            const cursor = document.createElement('span');
            cursor.className = 'typing-cursor';
            targetElement.appendChild(cursor); 

            for (let i = 0; i < text.length; i++) {
                const char = text.charAt(i);
                targetElement.insertBefore(document.createTextNode(char), cursor);
                
                playTypingSound(); 
                
                // UPDATED: Scroll the wrapper element
                chatScrollWrapper.scrollTop = chatScrollWrapper.scrollHeight; 
                await new Promise(resolve => setTimeout(resolve, delay));
            }
            
            targetElement.removeChild(cursor); 
        }

        async function saveUserMessage(text, files) {
            const parts = [];
            
            files.forEach(file => {
                parts.push({ inlineData: { data: file.data, mimeType: file.mimeType } });
            });
            
            parts.push({ text });

            const message = { role: 'user', parts };
            
            chatHistory.push(message);

            displayMessage(text, 'user', files);
        }

        window.clearHistory = function() {
            chatHistory = []; 
            chatHistoryDiv.innerHTML = ''; 
            
            initialMessageBox.classList.remove('hidden');
            chatScrollWrapper.prepend(initialMessageBox); // Prepend initial message box back to the wrapper
            clearFiles();

            systemStatusSpan.textContent = "Status: New Chat Started";
            
            setTimeout(() => {
                systemStatusSpan.textContent = "Status: Ready";
            }, 1000);
        }


        // --- File Handling ---

        window.clearFiles = function() {
            uploadedFiles = [];
            fileInput.value = '';
            fileListDiv.innerHTML = '';
            filePreviewArea.classList.add('hidden');
            userInput.focus();
        }

        window.previewFiles = function(event) {
            const files = event.target.files;
            if (files.length === 0) {
                clearFiles();
                return;
            }
            
            const maxFiles = 5; 
            uploadedFiles = [];
            fileListDiv.innerHTML = '';

            for (let i = 0; i < Math.min(files.length, maxFiles); i++) {
                const file = files[i];
                
                if (file.size > 10 * 1024 * 1024) { 
                    const listItem = document.createElement('div');
                    listItem.className = 'text-red-500';
                    listItem.textContent = `[!] ${file.name} is too large (>10MB) and skipped.`;
                    fileListDiv.appendChild(listItem);
                    continue;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const base64String = e.target.result.split(',')[1];
                    const mimeType = file.type || 'application/octet-stream';
                    
                    uploadedFiles.push({
                        data: base64String,
                        mimeType: mimeType,
                        name: file.name
                    });

                    const listItem = document.createElement('div');
                    listItem.className = 'flex items-center space-x-2';
                    const isDark = document.body.classList.contains('dark');

                    const iconColor = isDark ? 'text-gray-400' : 'text-indigo-500';

                    const icon = file.type.startsWith('image/') 
                        ? `<svg class="w-4 h-4 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>`
                        : `<svg class="w-4 h-4 ${iconColor}" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 2H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>`;
                    
                    listItem.innerHTML = icon + `<span class="truncate">${file.name}</span>`;
                    fileListDiv.appendChild(listItem);

                    if (files.length > maxFiles && i === maxFiles - 1) {
                         const warning = document.createElement('div');
                         warning.className = 'text-yellow-500 font-bold mt-2';
                         warning.textContent = `Warning: Only the first ${maxFiles} files were attached.`;
                         fileListDiv.appendChild(warning);
                    }
                };
                reader.readAsDataURL(file);
            }

            applyTheme(currentTheme); // Re-apply theme to update file preview colors
            filePreviewArea.classList.remove('hidden');
            userInput.focus();
        }

        // --- Geolocation Functionality ---
        window.getLocation = function() {
            if (!navigator.geolocation) {
                displayError("Geolocation is not supported by your browser.");
                return;
            }

            systemStatusSpan.textContent = "Status: Requesting Location...";
            
            locationBtn.disabled = true;
            locationBtn.classList.add('opacity-50');

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    userLocation = {
                        latitude: position.coords.latitude.toFixed(4),
                        longitude: position.coords.longitude.toFixed(4)
                    };
                    systemStatusSpan.textContent = `Location: Lat ${userLocation.latitude}, Lon ${userLocation.longitude}`;
                    
                    locationBtn.disabled = false;
                    locationBtn.classList.remove('opacity-50', 'bg-gray-500', 'hover:bg-gray-600');
                    locationBtn.classList.add('bg-cyan-500', 'hover:bg-cyan-600');
                },
                (error) => {
                    locationBtn.disabled = false;
                    locationBtn.classList.remove('opacity-50', 'bg-cyan-500', 'hover:bg-cyan-600');
                    locationBtn.classList.add('bg-gray-500', 'hover:bg-gray-600');

                    let errorMsg = "Could not retrieve location data.";
                    if (error.code === error.PERMISSION_DENIED) {
                        errorMsg = "Access Denied.";
                    }
                    systemStatusSpan.textContent = `Status: Location Error (${errorMsg})`;
                    userLocation = null; 
                }
            );
        }

        // --- Main Send Message Function ---

        window.sendMessage = async function() {
            const userQuery = userInput.value.trim();
            const currentFiles = [...uploadedFiles]; 
            
            if (!userQuery && currentFiles.length === 0) return;

            // --- UI State: User Message & Loading ---
            userInput.value = ''; 
            sendBtn.disabled = true;
            sendBtn.classList.add('opacity-70', 'cursor-not-allowed');
            systemStatusSpan.textContent = "Status: Thinking...";
            
            // 1. Save and display the user's message immediately
            let userTextForDisplay = userQuery || "";
            if (currentFiles.length > 0) {
                 userTextForDisplay = `${userTextForDisplay} (Attached ${currentFiles.length} file${currentFiles.length > 1 ? 's' : ''})`.trim();
            }

            await saveUserMessage(userTextForDisplay, currentFiles);
            clearFiles(); 

            // 2. Prepare the parts array for the API payload
            let parts = [];
            
            currentFiles.forEach(file => {
                parts.push({ inlineData: { data: file.data, mimeType: file.mimeType } });
            });
            
            let promptWithLocation = userQuery || "Analyze the provided files.";
            if (userLocation) {
                promptWithLocation = `(User Location: Lat ${userLocation.latitude}, Lon ${userLocation.longitude}) ${promptWithLocation}`;
            }
            parts.push({ text: promptWithLocation });

            // 3. Prepare chat history for API (context)
            const contentsForApi = [...chatHistory];
            if (contentsForApi.length > 0) {
                // Ensure the last entry in the contents array contains the full list of parts
                contentsForApi[contentsForApi.length - 1].parts = parts;
            }
            
            const limitedContentsForApi = contentsForApi.slice(-10);

            const payload = {
                contents: limitedContentsForApi, 
                tools: [{ "google_search": {} }], 
                systemInstruction: {
                    parts: [{ text: SYSTEM_PROMPT }]
                },
            };

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            // 4. Display model placeholder and fetch response
            const modelTextElement = displayMessage('', 'model', null); 
            let audioPlayer = null;
            let modelResponseText = null;

            try {
                const response = await fetchWithRetry(API_URL, options);
                const result = await response.json();
                
                modelResponseText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!modelResponseText) {
                    throw new Error("Received an empty or malformed response from the model.");
                }

                // 5. Determine typing speed and if TTS should be attempted
                let typingDelay = TYPING_DELAY;

                if (isTtsEnabled) {
                    if (modelResponseText.length >= TTS_MIN_LENGTH) {
                        audioPlayer = await generateAndPlayTts(modelResponseText);
                        if (audioPlayer) {
                            typingDelay = TTS_TYPING_SPEED; 
                        } 
                    } 
                }

                // 6. Run the typewriter effect (speed adjusted for TTS or not)
                await typewriterEffect(modelTextElement, modelResponseText, typingDelay);

                // 7. Save the final message to local memory (for subsequent context)
                const modelMessage = { role: 'model', parts: [{ text: modelResponseText }] };
                chatHistory.push(modelMessage);

            } catch (error) {
                console.error("API Error:", error);
                
                if (modelTextElement.parentNode) {
                    modelTextElement.parentNode.remove();
                }
                
                let displayMsg = `API connection error: ${error.message}. Please check the console for details.`;
                if (error.message.includes("Quota exceeded")) {
                     displayMsg = "API Quota Exceeded. Please try later or use the volume button to disable TTS and rely on text-only replies.";
                }
                displayError(displayMsg);

            } finally {
                sendBtn.disabled = false;
                sendBtn.classList.remove('opacity-70', 'cursor-not-allowed');
                userInput.focus();
                
                if (audioPlayer) {
                    audioPlayer.onended = () => {
                        systemStatusSpan.textContent = "Status: Ready";
                        URL.revokeObjectURL(audioPlayer.src);
                    };
                    if (audioPlayer.paused || audioPlayer.readyState === 4) {
                       systemStatusSpan.textContent = "Status: Ready";
                    }
                } else {
                    if (!systemStatusSpan.textContent.includes("Quota Exceeded") && 
                        !systemStatusSpan.textContent.includes("API Failed") &&
                        !systemStatusSpan.textContent.includes("Playback Blocked")) {
                       systemStatusSpan.textContent = "Status: Ready";
                    }
                }
            }
        }
        
        /**
         * Initialize the chat and apply saved theme
         */
        document.addEventListener('DOMContentLoaded', () => {
            const hasOnlyInitialMessage = initialMessageBox && initialMessageBox.parentNode === chatScrollWrapper;
            
            if (!hasOnlyInitialMessage && chatHistoryDiv.children.length === 0) {
                 // If the history div is empty, but the page loaded, ensure the initial message is visible if it wasn't rendered yet
                 initialMessageBox.classList.remove('hidden');
            } else if (chatHistoryDiv.children.length > 0) {
                 initialMessageBox.classList.add('hidden');
            }
            
            // Apply the saved theme on load
            applyTheme(currentTheme); 
        });

    </script>
</body>
</html>
