<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AyazAI: Full Screen Gen Z Chat</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for Inter font and clean aesthetics */
        body {
            font-family: 'Inter', sans-serif;
            /* Base styles for light mode */
            background: linear-gradient(135deg, #f0f4f8 0%, #e0e7ff 100%);
            color: #1a202c; /* Dark Text */
            height: 100vh;
            width: 100vw;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
            overflow: hidden; 
        }

        /* Dark Mode Overrides: Deeper, cooler tones */
        .dark body {
            background: linear-gradient(135deg, #1f2937 0%, #0f172a 100%);
            color: #f3f4f6; /* Light Text */
        }
        
        .app-container {
            width: 100vw; /* Take whole width */
            height: 100vh; /* Take whole height */
            background-color: white;
            border-radius: 0; /* Full screen, no rounding on the main container */
            box-shadow: none; 
        }
        
        .dark .app-container {
            background-color: #1f2937; 
        }

        /* Chat History Scroll Area */
        #chat-history {
            flex-grow: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; 
            padding: 1.5rem; /* More padding for Gen Z spacing */
        }

        /* Message Bubbles - Light Mode: Bubbly, clean look */
        .model-bubble {
            background-color: #e0f2fe; /* Light Blue */
            color: #0c4a6e;
            font-size: 1.05rem; /* Slightly larger text */
        }
        .user-bubble {
            background-color: #6366f1; /* Cool Indigo */
            color: white;
            font-size: 1.05rem;
            /* FIX: Ensure short text doesn't wrap inside the bubble */
            text-align: left;
        }

        /* Message Bubbles - Dark Mode: High contrast */
        .dark .model-bubble {
            background-color: #374151; /* Darker model bubble */
            color: #d1d5db; /* Light text */
        }
        .dark .user-bubble {
            background-color: #818cf8; /* Lighter indigo for dark mode contrast */
            color: #1f2937; 
        }
        
        .user-bubble, .model-bubble {
            padding: 1rem 1.25rem;
            /* Allow the bubble content itself to break words only if max width is hit */
            word-wrap: break-word; 
            overflow-wrap: break-word;
            white-space: pre-wrap; /* Preserve formatting for multi-line replies */
            
            /* Core Fix: Use display: inline-block to allow the element to shrink-wrap its content width-wise */
            display: inline-block; 
            max-width: 90%; 
            border-radius: 1.5rem 1.5rem 0.5rem 1.5rem; /* Fun asymmetry */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease-in-out;
            
            /* Add flex properties to manage image/text alignment within the bubble */
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* Ensure contents start from the left */
        }
        .model-bubble {
             border-radius: 1.5rem 1.5rem 1.5rem 0.5rem; /* Mirror asymmetry */
        }
        
        .bubble-image {
            max-height: 10rem; /* Constrain image size */
            width: auto;
            max-width: 100%;
            border-radius: 0.75rem;
            object-fit: contain;
            margin-bottom: 0.5rem; /* Space between image and text */
        }

        /* Container Fix: Ensure containers correctly align the bubbles */
        .user-bubble-container {
            align-self: flex-end; 
            display: flex; 
            justify-content: flex-end;
        }
        .model-bubble-container {
            align-self: flex-start;
            display: flex;
            justify-content: flex-start;
        }

        /* Typing Indicator Styles */
        .typing-indicator-dot {
            width: 8px; /* Bigger dots */
            height: 8px;
            background-color: #90a4ae; 
            border-radius: 50%;
            margin: 0 3px;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .dark .typing-indicator-dot {
             background-color: #9ca3af; 
        }
        .typing-indicator-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator-dot:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }

        /* Location Status Glow */
        .location-active {
            animation: pulse-border 1.5s infinite;
        }
        @keyframes pulse-border {
            0% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.7); } /* Indigo focus */
            70% { box-shadow: 0 0 0 10px rgba(99, 102, 241, 0); }
            100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0); }
        }
        
        /* Input Field Styling */
        #user-input {
            border-radius: 9999px; /* Full pill shape */
            padding-left: 1.5rem;
            background-color: #f9fafb;
            border: 2px solid #d1d5db;
            color: #1a202c; 
        }
        .dark #user-input {
            background-color: #374151;
            border-color: #4b5563;
            color: #f3f4f6;
        }

    </style>
</head>
<body class="p-0 m-0 transition-colors duration-300">

    <!-- Main App Container (Takes up the whole screen) -->
    <div class="app-container flex flex-col transition-colors duration-300 overflow-hidden">
        
        <!-- Header Section (COMPACTED FOR MOBILE) -->
        <header class="p-3 flex justify-between items-center border-b shadow-md flex-shrink-0 bg-white dark:bg-gray-900 dark:border-gray-700 transition-colors duration-300">
            
            <div class="flex items-center space-x-2">
                
                <!-- Theme Toggle Button (Shrunk) -->
                <button id="theme-toggle-btn" 
                        class="p-2 rounded-full text-indigo-600 dark:text-yellow-400 bg-indigo-100 dark:bg-gray-700 transition-colors hover:bg-indigo-200 dark:hover:bg-gray-600 focus:outline-none focus:ring-4 focus:ring-indigo-300 dark:focus:ring-yellow-500 shadow-md w-10 h-10 flex items-center justify-center" 
                        onclick="toggleTheme()">
                    <svg id="theme-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
                    </svg>
                </button>
                
                <!-- New Chat Button (Shrunk) -->
                <button id="new-chat-btn" 
                        class="p-2 rounded-full bg-red-500 text-white transition-colors hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300 shadow-md w-10 h-10 flex items-center justify-center" 
                        onclick="showConfirmClearHistory()">
                    <!-- Trash/New Icon -->
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.74 9l-.387 7.054a2 2 0 01-1.995 2.5l-2.673-.535a2 2 0 01-1.995-2.5L9.26 9m1.06 4.676l-1.06-1.06M12 6h6"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5v-1a1 1 0 011-1h4a1 1 0 011 1v1M5 7h14a1 1 0 011 1v12a2 2 0 01-2 2H6a2 2 0 01-2-2V8a1 1 0 011-1z"></path></svg>
                </button>
                
                <!-- Gen Z Title (Shrunk) -->
                <h1 class="text-2xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-indigo-500 to-purple-500 tracking-tight ml-2">
                    AyazAI Vibe
                </h1>
            </div>
            
            <!-- Status Badge & Location (Consolidated) -->
            <div class="flex items-center space-x-2 text-right">
                <span id="system-status" class="text-xs p-1 px-2 bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 rounded-lg transition-colors duration-300 font-semibold">Status: Ready</span>
                <span id="location-status" class="text-xs p-1 px-2 rounded-lg transition-all border text-gray-500 dark:text-gray-400 border-gray-300 dark:border-gray-600 font-medium">
                    Loc: Off
                </span>
            </div>
        </header>

        <!-- Chat History Display -->
        <div id="chat-history" class="chat-history-bg flex flex-col space-y-4 bg-gray-50 dark:bg-gray-800 transition-colors duration-300">
            <!-- Initial Welcome Message -->
            <div id="initial-message-box" class="model-bubble p-3 shadow-md model-bubble-container">
                <span id="initial-message">What's good? I'm AyazAI, and I'm here to serve the vibes. Text and audio are synced up, **no cap**. Hit me with your query!</span>
            </div>
            
            <!-- Typing Indicator (Replaces generic spinner) -->
            <div id="typing-indicator" class="hidden my-2 model-bubble-container">
                <div class="model-bubble text-sm text-gray-600 dark:text-gray-300 flex items-center p-3">
                    <span class="mr-3 font-semibold">AyazAI is typing...</span>
                    <div class="flex">
                        <div class="typing-indicator-dot"></div>
                        <div class="typing-indicator-dot"></div>
                        <div class="typing-indicator-dot"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Image Preview Area -->
        <div id="image-preview-area" class="p-3 flex-shrink-0 bg-gray-50 dark:bg-gray-900 border-t dark:border-gray-700 hidden">
            <p class="text-xs font-semibold text-gray-600 dark:text-gray-400 mb-2">Attached Image (Slay):</p>
            <div class="flex items-center space-x-3">
                <img id="image-preview" class="max-h-24 w-auto rounded-xl object-contain border-2 border-indigo-300 dark:border-indigo-600" src="" alt="Image Preview">
                <button onclick="clearImage()" class="text-sm text-red-500 font-bold hover:text-red-700 transition" id="remove-image-btn">Remove That</button>
            </div>
        </div>


        <!-- Chat Input Section (COMPACTED FOR MOBILE) -->
        <div class="p-2 border-t flex space-x-2 flex-shrink-0 bg-white dark:bg-gray-900 dark:border-gray-700 transition-colors duration-300 shadow-inner">
            
            <!-- Location Button (Map Icon) (Shrunk) -->
            <button id="location-btn" 
                    class="p-2 bg-indigo-500 text-white rounded-full focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all hover:bg-indigo-600 shadow-lg flex items-center justify-center w-12 h-12 flex-shrink-0 hover:scale-105" 
                    onclick="getLocation()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.828 0l-4.243-4.243m.707-8.243a7 7 0 119.899 9.899L12 20.908l-5.303-5.303a7 7 0 019.899-9.899z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            </button>
            
            <!-- Image Upload Button (Shrunk) -->
            <button id="image-upload-btn" 
                    class="p-2 bg-purple-500 text-white rounded-full focus:outline-none focus:ring-4 focus:ring-purple-300 transition-all hover:bg-purple-600 shadow-lg flex items-center justify-center w-12 h-12 flex-shrink-0 hover:scale-105"
                    onclick="document.getElementById('image-input').click()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.414 5h3.172a2 2 0 011.664.89l.812 1.22a2 2 0 001.664.89H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            </button>
            
            <!-- Hidden File Input -->
            <input type="file" id="image-input" accept="image/*" class="hidden" onchange="previewImage(event)">

            <input type="text" id="user-input" placeholder="Type your query here, fam..."
                    class="flex-grow p-3 border rounded-full focus:ring-indigo-500 focus:border-indigo-500 transition-colors placeholder-gray-400 text-base dark:text-white"
                    onkeypress="if(event.key === 'Enter') sendMessage()">
            
            <!-- Send Button (Shrunk) -->
            <button id="send-btn" 
                    class="p-2 bg-gradient-to-r from-indigo-500 to-purple-600 text-white rounded-full hover:from-indigo-600 hover:to-purple-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all shadow-xl w-12 h-12 flex items-center justify-center flex-shrink-0 hover:scale-105"
                    onclick="sendMessage()">
                <svg id="button-icon" class="w-6 h-6 rotate-90" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.25a.75.75 0 01.75.75v16.19l3.72-3.72a.75.75 0 111.06 1.06l-5 5a.75.75 0 01-1.06 0l-5-5a.75.75 0 111.06-1.06l3.72 3.72V3a.75.75 0 01.75-.75z"></path></svg>
            </button>
        </div>
        
        <!-- Custom Modal for Errors -->
        <div id="error-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div class="bg-white dark:bg-gray-800 rounded-2xl p-6 w-full max-w-sm transform transition-all shadow-2xl">
                <h3 class="text-xl font-bold text-red-600 dark:text-red-400 mb-3">Wait, Hol' Up! (System Alert)</h3>
                <p id="error-message" class="text-gray-700 dark:text-gray-300 mb-4">An unknown error occurred. That's rough, buddy.</p>
                <button class="w-full py-3 bg-red-600 text-white font-semibold rounded-xl hover:bg-red-700 transition" onclick="document.getElementById('error-modal').classList.add('hidden')">Acknowledge</button>
            </div>
        </div>
        
        <!-- Custom Modal for Confirmation (New Chat) -->
        <div id="confirm-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div class="bg-white dark:bg-gray-800 rounded-2xl p-6 w-full max-w-sm transform transition-all shadow-2xl">
                <h3 class="text-xl font-bold text-indigo-600 dark:text-indigo-400 mb-3">For Real? (Confirm New Chat)</h3>
                <p class="text-gray-700 dark:text-gray-300 mb-6">Are you sure you wanna clear the history? This session's chat will be *gone*. No take-backs.</p>
                <div class="flex justify-end space-x-3">
                    <button class="py-2 px-4 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-300 font-semibold rounded-xl hover:bg-gray-400 dark:hover:bg-gray-500 transition" onclick="document.getElementById('confirm-modal').classList.add('hidden')">Nah, Cancel</button>
                    <button class="py-2 px-4 bg-red-600 text-white font-semibold rounded-xl hover:bg-red-700 transition" onclick="performClearHistory()">Clear it, fam</button>
                </div>
            </div>
        </div>
        
        <!-- Location Permission Modal -->
        <div id="permission-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
            <div class="bg-white dark:bg-gray-800 rounded-2xl p-6 w-full max-w-sm transform transition-all shadow-2xl">
                <h3 class="text-xl font-bold text-indigo-600 dark:text-indigo-400 mb-3">Gotta Have Location Perms</h3>
                <p id="permission-message" class="text-gray-700 dark:text-gray-300 mb-4">Location access got denied. That's a fail.</p>
                <p class="text-sm text-gray-500 dark:text-gray-400 mb-6">**Fix it:** Head to your browser's site settings for this page and switch Location permission from **"Block"** to **"Allow"**. Then hit that map button again!</p>
                <button class="w-full py-3 bg-indigo-600 text-white font-semibold rounded-xl hover:bg-indigo-700 transition" onclick="document.getElementById('permission-modal').classList.add('hidden')">Bet</button>
            </div>
        </div>

    </div>

    <script type="module">
        // --- API Key Comment ---
        const apiKey = ""; 

        // --- Global State ---
        let userLocation = null; 
        let uploadedImage = null; 
        let chatHistory = []; 
        const TYPING_SPEED = 10; 
        
        // --- DOM Elements ---
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const locationStatusSpan = document.getElementById('location-status'); 
        const chatHistoryDiv = document.getElementById('chat-history');
        const typingIndicator = document.getElementById('typing-indicator'); 
        const errorModal = document.getElementById('error-modal');
        const errorMessage = document.getElementById('error-message');
        const confirmModal = document.getElementById('confirm-modal'); 
        const systemStatusSpan = document.getElementById('system-status');
        const initialMessageBox = document.getElementById('initial-message-box');
        const imageInput = document.getElementById('image-input');
        const imagePreview = document.getElementById('image-preview');
        const imagePreviewArea = document.getElementById('image-preview-area');
        const permissionModal = document.getElementById('permission-modal'); 
        const htmlElement = document.documentElement;
        const themeIcon = document.getElementById('theme-icon');

        // --- API Constants ---
        const MODEL_NAME = 'gemini-2.5-flash-preview-09-2025';
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;
        const TTS_MODEL = 'gemini-2.5-flash-preview-tts';
        const SYSTEM_PROMPT = "You are AyazAI, a super casual, helpful, and fun assistant with a Gen Z persona. Use common slang (no cap, slay, vibe, fam, bet, that's wild, etc.) appropriately and keep your tone conversational and light. You must use your search tool for any current or real-time info. Your responses must be in plain text and should not use markdown formatting like **bolding** or *italics* as the client UI handles formatting. If the user includes location data (e.g., 'User Location: [LAT, LON]'), use it if relevant, but integrate it smoothly into your Gen Z persona (e.g., 'Bet, I see you're chilling at [Location]'). Keep it short and witty.";

        
        // --- Theme Management ---

        function setTheme(theme) {
            if (theme === 'dark') {
                htmlElement.classList.add('dark');
                themeIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>`; // Moon icon
                localStorage.setItem('theme', 'dark');
            } else {
                htmlElement.classList.remove('dark');
                themeIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>`; // Sun icon
                localStorage.setItem('theme', 'light');
            }
        }

        window.toggleTheme = function() {
            const currentTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            setTheme(currentTheme === 'light' ? 'dark' : 'light');
        }

        function initializeTheme() {
            const storedTheme = localStorage.getItem('theme');
            if (storedTheme) {
                setTheme(storedTheme);
            } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                setTheme('dark');
            } else {
                setTheme('light');
            }
        }


        // --- Utility Functions ---

        function displayError(message) {
            errorMessage.textContent = message;
            errorModal.classList.remove('hidden');
            // Do not hide loading/reenable buttons here, as it's handled in the finally block
        }

        async function fetchWithRetry(url, options, maxRetries = 3, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status === 429 && i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                        continue;
                    }
                    if (!response.ok) {
                        const errorData = await response.json();
                        // Throw a structured error that can be handled outside
                        throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) {
                        // Throw on the last attempt
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; 
                }
            }
        }
        
        function stripMarkdown(text) {
            let cleanedText = text.replace(/```.*?```/gs, ''); 
            cleanedText = cleanedText.replace(/\*\*/g, ''); 
            cleanedText = cleanedText.replace(/\*/g, '');  
            cleanedText = cleanedText.replace(/_/g, '');  
            
            return cleanedText.trim();
        }

        /**
         * Creates and appends a new message bubble container.
         * @param {string} role 'user' or 'model'
         * @param {string} initialText Text content (for model, this will be empty and typed into later)
         * @param {string | null} imageUrl Base64 data URL for the image
         * @returns {HTMLElement} The span element containing the text for typing (or immediate display)
         */
        function createMessageBubble(role, initialText = '', imageUrl = null) {
            if (chatHistory.length > 0 && !initialMessageBox.classList.contains('hidden')) {
                initialMessageBox.classList.add('hidden');
            }
            
            const messageContainer = document.createElement('div');
            messageContainer.className = `${role}-bubble-container mb-4`;

            const messageWrapper = document.createElement('div');
            // Use role-specific classes for styling
            messageWrapper.className = `${role}-bubble shadow-lg`; 
            
            if (imageUrl) {
                const img = document.createElement('img');
                img.src = imageUrl;
                img.className = 'bubble-image'; // Use the dedicated CSS class
                messageWrapper.appendChild(img);
            }

            const textSpan = document.createElement('span');
            textSpan.textContent = initialText; 
            messageWrapper.appendChild(textSpan);
            
            messageContainer.appendChild(messageWrapper);
            chatHistoryDiv.appendChild(messageContainer);
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight; 
            
            return textSpan;
        }

        function typeText(targetElement, fullText) {
            return new Promise(resolve => {
                let i = 0;
                
                function type() {
                    if (i < fullText.length) {
                        let char = fullText.charAt(i);
                        
                        if (char === '\n') {
                            targetElement.innerHTML += '<br>';
                        } else {
                            targetElement.innerHTML += char;
                        }

                        if (i % 5 === 0) {
                            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
                        }

                        i++;
                        setTimeout(type, TYPING_SPEED);
                    } else {
                        resolve();
                    }
                }
                type();
            });
        }
        
        async function saveMessage(role, text, image = null) {
            const parts = [];
            
            if (image) {
                parts.push({ inlineData: { data: image.data, mimeType: image.mimeType } });
            }
            
            const messageText = text || (role === 'user' ? "Image attached." : "Response");
            parts.push({ text: messageText });

            const message = { role, parts };
            
            chatHistory.push(message);
        }

        window.showConfirmClearHistory = function() {
            confirmModal.classList.remove('hidden');
        }

        window.performClearHistory = function() {
            confirmModal.classList.add('hidden');
            
            chatHistory = []; 
            chatHistoryDiv.innerHTML = ''; 
            
            userLocation = null;
            updateLocationStatus('off');

            initialMessageBox.classList.remove('hidden');
            const initialMessageContainer = document.createElement('div');
            initialMessageContainer.className = 'model-bubble-container';
            initialMessageContainer.appendChild(initialMessageBox);
            chatHistoryDiv.appendChild(initialMessageContainer);

            systemStatusSpan.textContent = "Status: New Chat";
            console.log("Chat history cleared locally.");
        }


        // --- Image Handling ---

        window.clearImage = function() {
            uploadedImage = null;
            imageInput.value = '';
            imagePreview.src = '';
            imagePreviewArea.classList.add('hidden');
            userInput.focus();
        }

        window.previewImage = function(event) {
            const file = event.target.files[0];
            if (!file) {
                clearImage();
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const base64String = e.target.result.split(',')[1];
                const mimeType = file.type;
                
                uploadedImage = {
                    data: base64String,
                    mimeType: mimeType
                };

                imagePreview.src = e.target.result;
                imagePreviewArea.classList.remove('hidden');
                userInput.focus();
            };
            reader.readAsDataURL(file);
        }

        // --- Geolocation Functionality ---

        function updateLocationStatus(state, message = '') {
            
            locationStatusSpan.classList.remove('location-active', 'bg-indigo-200', 'text-indigo-900', 'bg-red-500', 'text-white', 'text-gray-500', 'border-gray-300', 'bg-white', 'dark:text-gray-400', 'dark:border-gray-600', 'bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300', 'bg-red-500', 'border-red-600');
            
            if (state === 'acquiring') {
                locationStatusSpan.textContent = 'Loc: Acquiring...';
                locationStatusSpan.classList.add('location-active', 'bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300', 'border-gray-400');
            } else if (state === 'acquired') {
                const lat = userLocation.lat.toFixed(4);
                const lon = userLocation.lon.toFixed(4);
                locationStatusSpan.textContent = `Loc: ${lat}, ${lon} (Slay)`;
                locationStatusSpan.classList.add('bg-indigo-200', 'text-indigo-900', 'border-indigo-400', 'location-active');
            } else if (state === 'denied') {
                locationStatusSpan.textContent = `Loc: Denied`;
                locationStatusSpan.classList.add('bg-red-500', 'text-white', 'border-red-600');
                permissionModal.classList.remove('hidden');
            } else { // 'off' or error
                locationStatusSpan.textContent = `Loc: Off${message ? ` (${message})` : ''}`;
                locationStatusSpan.classList.add('text-gray-500', 'dark:text-gray-400', 'border-gray-300', 'dark:border-gray-600', 'bg-white', 'dark:bg-gray-800');
            }
        }


        window.getLocation = function() {
            if (navigator.geolocation) {
                updateLocationStatus('acquiring');

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        userLocation = {
                            lat: position.coords.latitude,
                            lon: position.coords.longitude
                        };
                        updateLocationStatus('acquired');
                        console.log("Location acquired:", userLocation);
                    },
                    (error) => {
                        userLocation = null;
                        if (error.code === error.PERMISSION_DENIED) {
                            updateLocationStatus('denied');
                        } else {
                            updateLocationStatus('off', 'GPS Error');
                            console.error("Geolocation Error:", error.message);
                        }
                    },
                    { enableHighAccuracy: false, timeout: 5000, maximumAge: 0 }
                );
            } else {
                displayError("Geolocation is not supported by your browser. That's a throwback, fam.");
                updateLocationStatus('off', 'Unsupported');
            }
        }


        // --- Text-to-Speech (TTS) Implementation ---
        
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2; 
            const buffer = new ArrayBuffer(44 + pcm16.length * bytesPerSample);
            const view = new DataView(buffer);
            let offset = 0;

            // RIFF chunk
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, 36 + pcm16.length * bytesPerSample, true); offset += 4;
            writeString(view, offset, 'WAVE'); offset += 4;
            
            // fmt chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4;
            view.setUint16(offset, 1, true); offset += 2; 
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, sampleRate * numChannels * bytesPerSample, true); offset += 4; 
            view.setUint16(offset, numChannels * bytesPerSample, true); offset += 2; 
            view.setUint16(offset, bytesPerSample * 8, true); offset += 2; 
            
            // data chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, pcm16.length * bytesPerSample, true); offset += 4;

            // Write PCM data
            for (let i = 0; i < pcm16.length; i++, offset += 2) {
                view.setInt16(offset, pcm16[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }


        /**
         * Calls the TTS model to convert text to speech and plays the audio.
         */
        async function speakText(text) {
            const TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL}:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{
                    parts: [{ text: text }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Kore" } 
                        }
                    }
                },
                model: TTS_MODEL
            };

            try {
                const response = await fetchWithRetry(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    const rateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000; 

                    const pcmDataBuffer = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmDataBuffer);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    
                    const audioUrl = URL.createObjectURL(wavBlob);
                    const audio = new Audio(audioUrl);
                    
                    // Return a promise that resolves when audio finishes playing
                    return new Promise((resolve) => {
                        audio.onended = resolve;
                        audio.onerror = () => {
                            console.error("Audio playback error.");
                            resolve(); // Resolve anyway to not block the chat flow
                        };
                        audio.play().catch(e => {
                            console.error("Audio playback failed:", e);
                            resolve(); // Resolve anyway
                        });
                    });

                } else {
                    console.warn("TTS response missing audio data or incorrect mime type. Resolving immediately.");
                    return Promise.resolve();
                }
            } catch (error) {
                console.error("TTS API Error during speech generation:", error);
                return Promise.resolve(); // Resolve immediately on error
            }
        }


        // --- Main Send Message Function ---

        window.sendMessage = async function() {
            const userQuery = userInput.value.trim();
            if (!userQuery && !uploadedImage) return;

            // --- UI State: User Message & Loading ---
            userInput.value = ''; 
            sendBtn.disabled = true;
            sendBtn.classList.add('opacity-70', 'cursor-not-allowed');
            typingIndicator.classList.remove('hidden'); 
            systemStatusSpan.textContent = "Status: Vibe Check In Progress...";

            let promptText = userQuery;
            if (userLocation) {
                promptText = `User Location: [${userLocation.lat.toFixed(6)}, ${userLocation.lon.toFixed(6)}]. Query: ${userQuery}`;
            } else {
                promptText = userQuery || "Image attached. Send me the deets.";
            }

            const currentImage = uploadedImage;
            
            // 1. Save and display the user's message immediately
            const imageUrl = currentImage ? `data:${currentImage.mimeType};base64,${currentImage.data}` : null;
            createMessageBubble('user', userQuery || "Image attached.", imageUrl);
            await saveMessage('user', userQuery, currentImage);
            
            // Clear location and image state immediately after using them
            userLocation = null;
            updateLocationStatus('off');
            clearImage();

            // 2. Prepare chat history for API (context)
            const contentsForApi = [...chatHistory]; 
            const lastContent = contentsForApi[contentsForApi.length - 1];
            const textPart = lastContent.parts.find(p => p.text !== undefined);
            if (textPart) {
                // Ensure the last message's text part includes all contextual info
                textPart.text = promptText; 
            }
            
            const limitedContentsForApi = contentsForApi.slice(-10); 

            const payload = {
                contents: limitedContentsForApi, 
                tools: [{ "google_search": {} }], 
                systemInstruction: {
                    parts: [{ text: SYSTEM_PROMPT }]
                },
            };

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            let modelResponseText = null;

            try {
                // Get the model's response text first
                const response = await fetchWithRetry(API_URL, options);
                const result = await response.json();
                
                modelResponseText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!modelResponseText) {
                    throw new Error("Received an empty or malformed response from the model. That's a hard fail.");
                }
                
                const cleanResponseText = stripMarkdown(modelResponseText);
                
                // Hide indicator, update status for typing/speaking
                typingIndicator.classList.add('hidden'); 
                systemStatusSpan.textContent = "Status: Speaking That Truth...";

                // Create the model bubble and get the element where text will be typed
                const targetTextElement = createMessageBubble('model', '');
                
                // 3. Start typing animation and TTS generation concurrently.
                // We don't need to await the typing here if the TTS is playing, 
                // but awaiting both ensures the message is fully "sent" when done.
                const typingPromise = typeText(targetTextElement, cleanResponseText);
                const speakingPromise = speakText(cleanResponseText);
                
                // Wait for both tasks to complete for UI stability and synchronization
                await Promise.all([typingPromise, speakingPromise]);

                // 4. Save the final message to history
                await saveMessage('model', cleanResponseText);


            } catch (error) {
                // Log and display error without changing status/buttons, as finally handles cleanup
                console.error("API Error:", error);
                const errorMsg = error.message.includes("API connection error") ? error.message : `API connection error: ${error.message}`;
                displayError(errorMsg); 
                // Re-throw or use a flag if needed, but displayError takes care of the modal
            } finally {
                // Clean up UI state regardless of success or failure
                typingIndicator.classList.add('hidden');
                sendBtn.disabled = false;
                sendBtn.classList.remove('opacity-70', 'cursor-not-allowed');
                userInput.focus();
                systemStatusSpan.textContent = "Status: Ready";
            }
        }
        
        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeTheme();
            updateLocationStatus('off');
            
            // Re-wrap initial message for correct alignment
            const initialMessageContainer = document.createElement('div');
            initialMessageContainer.className = 'model-bubble-container';
            initialMessageContainer.appendChild(initialMessageBox);
            chatHistoryDiv.appendChild(initialMessageContainer);
        });
    </script>
</body>
</html>
